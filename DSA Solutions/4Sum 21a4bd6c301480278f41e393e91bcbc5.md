# 4Sum

Difficulty: medium
 : Yes
: June 22, 2025
Problem: array, two pointers
Time Taken: 20 minutes

## Four Sum Problem â€“ Notes (Built on Top of 3Sum)

### ğŸ§  Problem Statement

We are given an array `nums[]` and a target, and we need to find all **unique quadruplets** `(a, b, c, d)` such that:

```
a + b + c + d == target

```

and all elements are **distinct** (`i â‰  j â‰  k â‰  l`).

---

### ğŸ’­ If Youâ€™ve Done 3Sum...

Really solvable problem **if you've already done 3Sum**.

You just need to **extend the idea** â€” instead of fixing 1 number and using 2 pointers, fix **2 numbers** and use 2 pointers on the rest.

I followed the same steps from my **3Sum Notion page**.

---

### ğŸ”§ Steps (Same Foundation as 3Sum):

- âœ… **Sort the array**
- âœ… Fix two elements using nested loops: `i` and `j`
- âœ… Use **two-pointer** technique with `left` and `right`
- âœ… Avoid duplicates on all 4 positions

```cpp
sort(nums.begin(), nums.end());
for (int i = 0; i < nums.size() - 3; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) continue;
    for (int j = i + 1; j < nums.size() - 2; j++) {
        if (j > i + 1 && nums[j] == nums[j - 1]) continue;
        int left = j + 1, right = nums.size() - 1;
        long long t = (long long)target - (long long)nums[i] - (long long)nums[j];
        while (left < right) {
            long long sum = (long long)nums[left] + (long long)nums[right];
            if (sum == t) {
                res.push_back({nums[i], nums[j], nums[left], nums[right]});
                left++, right--;
                while (left < right && nums[left] == nums[left - 1]) left++;
                while (left < right && nums[right] == nums[right + 1]) right--;
            } else if (sum < t) {
                left++;
            } else {
                right--;
            }
        }
    }
}

```

---

### âš ï¸ Mistakes I Made & How I Solved Them

- âŒ **Forgot braces** around `if` blocks â€” caused the logic to skip entirely.
    
    âœ… Fixed by adding `{}` around `continue` blocks properly.
    
- âŒ **Signed integer overflow** when doing `nums[i] + nums[j]`
    
    âœ… Solved by casting everything to `long long`:
    
    ```cpp
    long long t = (long long)target - (long long)nums[i] - (long long)nums[j];
    
    ```
    
- âŒ **Heap-buffer-overflow** due to accessing elements in small arrays (size < 4)
    
    âœ… Fixed by early check:
    
    ```cpp
    if (nums.size() < 4) return {};
    
    ```
    
- âœ… Updated loop bounds to avoid going out of range:
    
    ```cpp
    for (int i = 0; i < nums.size() - 3; i++)
    for (int j = i + 1; j < nums.size() - 2; j++)
    
    ```
    

---

### ğŸ§ª Think of it as:

> "Fix two, 2Sum the rest."
> 

Same as 3Sumâ€™s:

> "Fix one, 2Sum the rest."
> 

---

### â± Time and Space Complexity

- **Time:** O(nÂ³)
- **Space:** O(1) (ignoring result vector)

---

### ğŸ”‘ Key Takeaways

- Reuse 3Sum logic â€” just one extra loop.
- Handle **duplicate skipping** very carefully at all 4 levels.
- Always think about **overflow**, especially in problems involving large sums.
- Check array size early to avoid runtime memory issues.

### A More Efficient Approach â€” Two Pointer (Slow & Fast)

We use a **two-pointer technique** with:

- `index` â†’ **slow pointer**, tracks the **last unique element's position**
- `i` â†’ **fast pointer**, traverses the full array

---

### ğŸ§  How It Works:

- Set `index = 0`
- Traverse the array from `i = 0` to `n - 1`
- For every `i`, check if `nums[i] != nums[index]`
    - If **true**, increment `index` and store the unique element at `nums[index]`

---

### ğŸ”§ Code:

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int index = 0; // slow pointer starts at 0
        for (int i = 0; i < nums.size(); i++) {
            if (nums[index] != nums[i]) {
                nums[++index] = nums[i]; // store unique element at next position
            }
        }
        return index + 1; // size of array with unique elements
    }
};

```

---

### ğŸ” Dry Run Example:

Given: `nums = [0, 1, 1, 2, 2, 3]`

- `index = 0`, `i = 0` â†’ `nums[0] == nums[0]` â†’ skip
- `i = 1` â†’ `nums[1] != nums[0]` â†’ `++index = 1`, `nums[1] = nums[1]`
- `i = 2` â†’ `nums[2] == nums[1]` â†’ skip
- `i = 3` â†’ `nums[3] != nums[1]` â†’ `++index = 2`, `nums[2] = nums[3]` â†’ `nums = [0,1,2,...]`
- `i = 4` â†’ `nums[4] == nums[2]` â†’ skip
- `i = 5` â†’ `nums[5] != nums[2]` â†’ `++index = 3`, `nums[3] = nums[5]`

Final result:

```cpp
nums = [0, 1, 2, 3, 2, 3]
return 4

```

So the first `4` elements are the **unique** ones.

---

### ğŸ”‘ Key Takeaways:

- This approach modifies the array **in-place**.
- Space complexity: `O(1)`
- Time complexity: `O(n)`
- Ideal when youâ€™re **removing duplicates from a sorted array**