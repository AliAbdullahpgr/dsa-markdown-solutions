# 3Sum

Difficulty: medium
 : Yes
: June 21, 2025
Problem: array, hashtable/freq method, two pointers
Time Taken: 30 minutes

## Three Sum Problem - Notes (Optimized with Two Pointers)

### 🧠 Problem Statement

We are given an array `nums[]` and we need to find all **unique triplets** `(i, j, k)` such that:

```
nums[i] + nums[j] + nums[k] == 0

```

and `i ≠ j ≠ k`.

---

### 🐌 Brute Force Idea (O(n³))

- Three nested loops:
    - First loop `i` from `0` to `n`
    - Second loop `j` from `i+1` to `n`
    - Third loop `k` from `j+1` to `n`
- Check if `nums[i] + nums[j] + nums[k] == 0`
- If yes, store in result.

⛔ Problem: Time complexity is **O(n³)** — very slow for large input.

---

### ⚡ Optimized Idea – Two Pointer Approach (O(n²))

---

### 🔧 Steps:

1. **Sort the array** `nums`.
    - Because two-pointer only works on sorted arrays.
2. Fix one element using a loop (`i` from `0` to `n-1`).
3. For every fixed `nums[i]`, use two pointers:
    - `left = i + 1`
    - `right = nums.size() - 1`
4. Target becomes:
    
    ```cpp
    target = -nums[i]
    
    ```
    
5. Now check:
    
    ```cpp
    nums[left] + nums[right] == target
    
    ```
    
6. If it matches → push into result.

---

### 💡 Example to Understand

```cpp
Input: nums = [-1, 0, 1, 2, -1, -4]
Sorted:         [-4, -1, -1, 0, 1, 2]

```

- i = 0 → nums[i] = -4 → target = 4
    
    Check pairs with sum 4 in rest of array → no valid pair.
    
- i = 1 → nums[i] = -1 → target = 1
    
    Try to find two numbers that sum to 1:
    
    - left = 2 (nums[left] = -1), right = 5 (nums[right] = 2)
    - sum = -1 + 2 = 1 ✅
        
        → triplet = `{-1, -1, 2}`
        
        Skip duplicates on left/right now.
        
- i = 2 → nums[i] = -1 again
    
    Same as previous → skip because of duplicate check.
    
- i = 3 → nums[i] = 0 → target = 0
    
    Check pair (1 + -1 = 0) → triplet = `{-1, 0, 1}` ✅
    

---

### 🛑 Important Conditions

### 🔁 Skip duplicates:

- For `i`:
    
    ```cpp
    if(i > 0 && nums[i] == nums[i - 1]) continue;
    
    ```
    
- After finding a triplet, skip repeated elements:
    
    ```cpp
    while(left < right && nums[left] == nums[left - 1]) left++;
    while(left < right && nums[right] == nums[right + 1]) right--;
    
    ```
    

---

### 🧪 Final Code (Optimized O(n²))

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        for (int i = 0; i < nums.size(); i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; // skip duplicates
            int left = i + 1;
            int right = nums.size() - 1;
            int target = -nums[i];
            while (left < right) {
                int sum = nums[left] + nums[right];
                if (sum == target) {
                    res.push_back({nums[i], nums[left], nums[right]});
                    left++;
                    right--;
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                }
                else if (sum < target) left++;
                else right--;
            }
        }
        return res;
    }
};

```

---

### ⏱ Time and Space Complexity

- **Time:** O(n²)
- **Space:** O(1) (ignoring result vector)

---

### 🔑 Key Takeaways:

- Always **sort the array first** when using two pointers.
- Skip **duplicate values** for both `i` and `left/right` to avoid repeated triplets.
- Think of it as:
    
    > "Fix one, 2Sum the rest."
    > 

Absolutely! Here's a **clean and concise 4Sum note**, written as a short story while closely following your tone, structure, and learning path from 3Sum. I’ve reused your formatting and principles to build a 4Sum version on top of your original notes:

---

## Four Sum Problem – Notes (Built on Top of 3Sum)

### 🧠 Problem Statement

We are given an array `nums[]` and a target, and we need to find all **unique quadruplets** `(a, b, c, d)` such that:

```
a + b + c + d == target

```

and all elements are **distinct** (`i ≠ j ≠ k ≠ l`).

---

### 💭 If You’ve Done 3Sum...

Really solvable problem **if you've already done 3Sum**.

You just need to **extend the idea** — instead of fixing 1 number and using 2 pointers, fix **2 numbers** and use 2 pointers on the rest.

I followed the same steps from my **3Sum Notion page**.

---

### 🔧 Steps (Same Foundation as 3Sum):

- ✅ **Sort the array**
- ✅ Fix two elements using nested loops: `i` and `j`
- ✅ Use **two-pointer** technique with `left` and `right`
- ✅ Avoid duplicates on all 4 positions

```cpp
sort(nums.begin(), nums.end());
for (int i = 0; i < nums.size() - 3; i++) {
    if (i > 0 && nums[i] == nums[i - 1]) continue;
    for (int j = i + 1; j < nums.size() - 2; j++) {
        if (j > i + 1 && nums[j] == nums[j - 1]) continue;
        int left = j + 1, right = nums.size() - 1;
        long long t = (long long)target - (long long)nums[i] - (long long)nums[j];
        while (left < right) {
            long long sum = (long long)nums[left] + (long long)nums[right];
            if (sum == t) {
                res.push_back({nums[i], nums[j], nums[left], nums[right]});
                left++, right--;
                while (left < right && nums[left] == nums[left - 1]) left++;
                while (left < right && nums[right] == nums[right + 1]) right--;
            } else if (sum < t) {
                left++;
            } else {
                right--;
            }
        }
    }
}

```

---

### ⚠️ Mistakes I Made & How I Solved Them

- ❌ **Forgot braces** around `if` blocks — caused the logic to skip entirely.
    
    ✅ Fixed by adding `{}` around `continue` blocks properly.
    
- ❌ **Signed integer overflow** when doing `nums[i] + nums[j]`
    
    ✅ Solved by casting everything to `long long`:
    
    ```cpp
    long long t = (long long)target - (long long)nums[i] - (long long)nums[j];
    
    ```
    
- ❌ **Heap-buffer-overflow** due to accessing elements in small arrays (size < 4)
    
    ✅ Fixed by early check:
    
    ```cpp
    if (nums.size() < 4) return {};
    
    ```
    
- ✅ Updated loop bounds to avoid going out of range:
    
    ```cpp
    for (int i = 0; i < nums.size() - 3; i++)
    for (int j = i + 1; j < nums.size() - 2; j++)
    
    ```
    

---

### 🧪 Think of it as:

> "Fix two, 2Sum the rest."
> 

Same as 3Sum’s:

> "Fix one, 2Sum the rest."
> 

---

### ⏱ Time and Space Complexity

- **Time:** O(n³)
- **Space:** O(1) (ignoring result vector)

---

### 🔑 Key Takeaways

- Reuse 3Sum logic — just one extra loop.
- Handle **duplicate skipping** very carefully at all 4 levels.
- Always think about **overflow**, especially in problems involving large sums.
- Check array size early to avoid runtime memory issues.

---

Let me know if you want this version added to your Notion or converted to PDF/Markdown.